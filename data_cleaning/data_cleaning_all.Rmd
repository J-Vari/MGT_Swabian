---
title: "Data cleaning"
author: "Judit Vari"
date: "25 7 2024"
output: html_document
editor_options: 
  chunk_output_type: console
---
# load libraries for cleaning
```{r libraries, include=FALSE}
library (dplyr)
library(broom)
library(tidyverse)
library(corrr)
library(ggcorrplot)
library(car)
library(readr)
library(here)
library(stringr)
library(tidytext)
options(scipen=999)
```
# *Tasks male only*
## Audio evaluation
```{r male audio eval}
audio_eval_male <- read_delim(here("raw_data", "data_exp_86579-v59_task-ue28.csv"), col_names = TRUE, delim = ",")

### relevant columns for audio evaluations & rename

audio_eval_male%>%
  select(`Participant Public ID`, `UTC Date and Time`, `UTC Timestamp`, `Response Type`, `Response`, `Object Name`, `Task Name`, `Spreadsheet: Audio`, `Spreadsheet: Speaker`, `Spreadsheet: Speaker gender`, `Spreadsheet: Variety`,
         `Spreadsheet: Political orientation`, `Spreadsheet: Stimulus number`, `Spreadsheet: Stimulus1`, `Spreadsheet: Stimulus2`, `Spreadsheet: Stimulus3`, `Spreadsheet: Stimulus4`, `Spreadsheet: Stimulus5`, 
         `Spreadsheet: Stimulus6`, `Spreadsheet: Attention Check`, `Store: Attention Check`)%>%
  rename(Audio_Track = `Spreadsheet: Audio`, Speaker = `Spreadsheet: Speaker`, Speaker_Gender = `Spreadsheet: Speaker gender`, Lang.Variety_Audio = `Spreadsheet: Variety`,
         Polit_ori = `Spreadsheet: Political orientation`, Statement_no = `Spreadsheet: Stimulus number`, Att.check_acc = `Store: Attention Check`)%>%
  filter(`Response Type` == "response")%>%
  filter (str_starts(Speaker, "Exp"))->audio_eval_male

## remove markdown from values
audio_eval_male%>%
mutate(across(starts_with("Spreadsheet:"), ~ str_remove_all(., "\\*\\*")))-> audio_eval_male

## create one column with attribute related to rating
audio_eval_male%>%
mutate(Attribute = case_when(
  `Object Name` == "RatingScale_Stimulus1" ~ `Spreadsheet: Stimulus1`,
  `Object Name` == "RatingScale_Stimulus2" ~ `Spreadsheet: Stimulus2`,
  `Object Name` == "RatingScale_Stimulus3" ~ `Spreadsheet: Stimulus3`,
  `Object Name` == "RatingScale_Stimulus4" ~ `Spreadsheet: Stimulus4`,
  `Object Name` == "RatingScale_Stimulus5" ~ `Spreadsheet: Stimulus5`,
  `Object Name` == "RatingScale_Stimulus6" ~ `Spreadsheet: Stimulus6`,
  `Object Name` == "RatingScale_AttentionCheck" ~ `Spreadsheet: Attention Check`))->audio_eval_male

## delete unnecessary columns & elaborate levels of categorical variables
audio_eval_male%>%
  select(-starts_with("Spreadsheet:"), -`Response Type`)%>%
  mutate(Speaker_Gender = ifelse(Speaker_Gender=="f", "female", "male"))%>%
  mutate (Polit_ori = ifelse(Polit_ori == "l", "left", "right"))%>%
  mutate (Lang.Variety_Audio = ifelse(Lang.Variety_Audio == "st", "Standard German", "Regional Variety"))-> audio_eval_male

## Identify-final-accuracy
## select final response attention check accuracy
audio_eval_male %>%
  ungroup()%>%
  group_by(`Participant Public ID`) %>%
      mutate(Att.check_acc_last = last(Att.check_acc))%>%
  select(-Att.check_acc) %>%
  rename(Att.check_acc = Att.check_acc_last) -> audio_eval_male

## duplicates & data loss in audio_eval_male?
audio_eval_male%>%
  group_by(`Participant Public ID`)%>%
  count()-> pp_rows # 3 pp not normal row no of 168 but below (161 & 165) & above (189)

audio_eval_male%>%
  filter (`Participant Public ID` == "281093394820202" | `Participant Public ID` == "281348585989177" | `Participant Public ID` =="281427437681691")%>%
  group_by (Audio_Track, Attribute)%>%
  summarise(n_distinct(Attribute))-> pp_audio_check # no repeated attributes, what's the problem then?
```
## Origin & authenticity
```{r male origin authenticity_prep}
#read data
origin_authen_male <-read_delim(here("raw_data", "data_exp_86579-v59_task-brwb.csv"), col_names = TRUE, delim = ",")

#elaborate columns

origin_authen_male%>%
  select(`Participant Public ID`, `Response Type`, Response, `Spreadsheet: Display`, `Spreadsheet: Audio`, `Spreadsheet: Variety`, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)%>%
  rename(Target = `Spreadsheet: Display`, Audio = `Spreadsheet: Audio`, Variety = `Spreadsheet: Variety`)%>%
  filter (`Response Type` == "response")%>%
  mutate(Target_Concept = case_when(
    Target == "Political level" ~ "Political level",
    Target == "Paradigm check" ~ "Paradigm check",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "proximity_variety_non-st",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "st" ~ "proximity_variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "st" ~ "identity_lang.variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "identity_lang.variety_non-st",
    TRUE ~ NA_character_))%>%
  filter(Response != "continue")%>%
  select(-`Response Type`, -Target)%>%
  select(`Participant Public ID`, Response, Target_Concept, Audio, Variety, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)-> origin_authen_male
```
### clean open text "Paradigm Check"
```{r male orin_authen_para}
## separate Paradigm Check Level
origin_authen_male %>%
  mutate(
    Target_Concept = case_when(
      `Object ID` == "object-1145" ~ "Paradigm check 1",
      `Object ID` == "object-1146" ~ "Paradigm check 2",
      TRUE ~ Target_Concept)) -> origin_authen_male

# Identify  participants not deceived by the speaker illusion
## Preprocess answers to open text fields
origin_authen_male %>%
  mutate(Response_tidy = str_to_lower(Response)) -> origin_authen_male

## Create new variable (1 = deceived, 0 = not deceived)
origin_authen_male %>%
  mutate(deceived = ifelse(str_detect(Response_tidy, "(gleich|selb).{0,2} (person|sprecher|sprechende|stimme).*") |
           str_detect(Response_tidy, "(stimm).{0,2} (verstell).*"), 0, 1))%>%
  group_by(`Participant Public ID`) %>%
  mutate(deceived = case_when(
    any(deceived == 0) ~ 0,
    TRUE ~ deceived)) %>%
  ungroup() %>% 
  select(-Response_tidy) -> origin_authen_male
```
### origin & authenticity duplicates
```{r male origin authenticity_dupl}
## Check duplicates
origin_authen_male%>%
  group_by(`Participant Public ID`, Audio) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

origin_authen_male%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> pp_bckgr_rows # normal 168 but 4 pp above & below

origin_authen_male%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))#446


origin_authen_male%>%
  filter (`Participant Public ID` == "281162358237373" | `Participant Public ID` == "281082304369845" | `Participant Public ID` == "281251938576386")-> check_pp
## => double ratings/ duplicated coz pp changed their rating at a later time OR pp selected "__other" and added answer to open Q field


## Solution: create 2 new columns
### 1) select later response of pp depending on Time Stamp

origin_authen_male %>%
  group_by(`Participant Public ID`, Audio, Target_Concept) %>%
  mutate(Response_corrected = Response[which.max(`UTC Timestamp`)])->origin_authen_male

## 2) if "_other" selected, next line text box entry into new column, then drop duplicated "_other"

origin_authen_male%>%
  mutate(Response_Text_identity_lang.var = ifelse(Response == "__other", lead(Response), NA))%>%
  ungroup()%>%
  filter(!(Response_corrected == "__other" & is.na(Response_Text_identity_lang.var)))%>%
  distinct(`Participant Public ID`, Audio, Target_Concept, Variety, .keep_all = TRUE)%>%
  select(-Response, -`Object ID`,-`UTC Date and Time`)->origin_authen_male
```
# Prep origin & authenticity join

```{r male origin authenticity_wide}

## turn long into wide format to match different data sets
origin_authen_male%>%
  pivot_wider(names_from = "Target_Concept",
              values_from = "Response_corrected")->origin_authen_male

## fill NAs with repeated values in new columns from origin_authen

# Explicitly define the new columns to be filled
new_columns_to_fill <- c("Response_Text_identity_lang.var", "Political level",
                         "identity_lang.variety_non-st", "identity_lang.variety_st",
                         "Paradigm check 1", "Paradigm check 2", "deceived")

# Fill missing values in the specified columns within each participant
 origin_authen_male %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill), .direction = "downup") %>%
  ungroup()-> origin_authen_male
```
## Combine 2 data sets: audio eval, origin & authenticity
```{r male combine tasks}

audio_eval_male %>%
   left_join(origin_authen_male, 
             by = c("Participant Public ID" = "Participant Public ID", 
                    "Audio_Track" = "Audio"))%>%
  select(-Variety)-> combined_tasks_male


## fill NAs with repeated values from origin_authen

### define the new columns to be filled: 1 x answer each participant
new_columns_to_fill_1 <- c("Political level", "Paradigm check 1", "Paradigm check 2", "deceived")

### define the new columns to be filled: 2 x answer each participant depending audio

new_columns_to_fill_2 <- c("Response_Text_identity_lang.var",                          "identity_lang.variety_non-st", "identity_lang.variety_st", "proximity_variety_non-st", "identity_lang.variety_non-st", "proximity_variety_st")

# Fill missing values in the specified columns within each participant
 combined_tasks_male %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill_1), .direction = "downup") %>%
  ungroup()-> combined_tasks_male
 
 # Fill missing values in the specified columns within each participant and audio
 combined_tasks_male %>%
   ungroup()%>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill_2), .direction = "downup") %>%
  ungroup()-> combined_tasks_male
```
# Check duplicates combined data
```{r male combine data dupl}

## Check duplicates
combined_tasks_male%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

combined_tasks_male%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_male_rows # normal 168 but 4 pp above & below

combined_tasks_male %>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  mutate(Response = Response[which.max(`UTC Timestamp`)])%>%
  select(-`UTC Date and Time`, -`Object Name`)%>%
  distinct()->combined_tasks_male

## Check duplicates
combined_tasks_male%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates # 1pp

combined_tasks_male%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_male_rows # normal 168 but 2 pp below
```
# *Tasks female only*
## Audio evaluations 
```{r female audio_eval}
audio_eval_female <- read_delim(here("raw_data", "data_exp_86579-v59_task-v697.csv"), col_names = TRUE, delim = ",")  

### relevant columns for audio evaluations & rename

audio_eval_female%>%
  select(`Participant Public ID`, `UTC Date and Time`, `UTC Timestamp`, `Response Type`, `Response`, `Object Name`, `Task Name`, `Spreadsheet: Audio`, `Spreadsheet: Speaker`, `Spreadsheet: Speaker gender`, `Spreadsheet: Variety`,
         `Spreadsheet: Political orientation`, `Spreadsheet: Stimulus number`, `Spreadsheet: Stimulus1`, `Spreadsheet: Stimulus2`, `Spreadsheet: Stimulus3`, `Spreadsheet: Stimulus4`, `Spreadsheet: Stimulus5`, 
         `Spreadsheet: Stimulus6`, `Spreadsheet: Attention Check`, `Store: Attention Check`)%>%
  rename(Audio_Track = `Spreadsheet: Audio`, Speaker = `Spreadsheet: Speaker`, Speaker_Gender = `Spreadsheet: Speaker gender`, Lang.Variety_Audio = `Spreadsheet: Variety`,
         Polit_ori = `Spreadsheet: Political orientation`, Statement_no = `Spreadsheet: Stimulus number`, Att.check_acc = `Store: Attention Check`)%>%
  filter(`Response Type` == "response")%>%
  filter (str_starts(Speaker, "Exp"))->audio_eval_female

## remove markdown from values
audio_eval_female%>%
mutate(across(starts_with("Spreadsheet:"), ~ str_remove_all(., "\\*\\*")))-> audio_eval_female

## create one column with attribute related to rating
audio_eval_female%>%
mutate(Attribute = case_when(
  `Object Name` == "RatingScale_Stimulus1" ~ `Spreadsheet: Stimulus1`,
  `Object Name` == "RatingScale_Stimulus2" ~ `Spreadsheet: Stimulus2`,
  `Object Name` == "RatingScale_Stimulus3" ~ `Spreadsheet: Stimulus3`,
  `Object Name` == "RatingScale_Stimulus4" ~ `Spreadsheet: Stimulus4`,
  `Object Name` == "RatingScale_Stimulus5" ~ `Spreadsheet: Stimulus5`,
  `Object Name` == "RatingScale_Stimulus6" ~ `Spreadsheet: Stimulus6`,
  `Object Name` == "RatingScale_AttentionCheck" ~ `Spreadsheet: Attention Check`))->audio_eval_female

## delete unnecessary columns & elaborate levels of categorical variables
audio_eval_female%>%
  select(-starts_with("Spreadsheet:"), -`Response Type`)%>%
  mutate(Speaker_Gender = ifelse(Speaker_Gender=="FALSE", "female", "male"))%>%
  mutate (Polit_ori = ifelse(Polit_ori == "l", "left", "right"))%>%
  mutate (Lang.Variety_Audio = ifelse(Lang.Variety_Audio == "st", "Standard German", "Regional Variety"))-> audio_eval_female

## Identify-final-accuracy
## select final response attention check accuracy
audio_eval_female %>%
  ungroup()%>%
  group_by(`Participant Public ID`) %>%
  mutate(Att.check_acc_last = last(Att.check_acc))%>%
  select(-Att.check_acc) %>%
  rename(Att.check_acc = Att.check_acc_last) -> audio_eval_female

audio_eval_female%>%
  distinct()->audio_eval_female

## duplicates & data loss in audio_eval_male?
audio_eval_female%>%
  group_by(`Participant Public ID`)%>%
  count()-> pp_rows # 3 pp not normal row no of 168 but below (161 & 165) & above (189)

audio_eval_female%>%
  filter(`Participant Public ID`=="281162358538243")-> pp_check

```
## Origin & authenticity
```{r female origin_authenticity}
# read data
origin_authen_female <-read_delim(here("raw_data", "data_exp_86579-v59_task-8u1p.csv"), col_names = TRUE, delim = ",")

#elaborate columns

origin_authen_female%>%
  select(`Participant Public ID`, `Response Type`, Response, `Spreadsheet: Display`, `Spreadsheet: Audio`, `Spreadsheet: Variety`, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)%>%
  rename(Target = `Spreadsheet: Display`, Audio = `Spreadsheet: Audio`, Variety = `Spreadsheet: Variety`)%>%
  filter (`Response Type` == "response")%>%
  mutate(Target_Concept = case_when(
    Target == "Political level" ~ "Political level",
    Target == "Paradigm check" ~ "Paradigm check",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "proximity_variety_non-st",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "st" ~ "proximity_variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "st" ~ "identity_lang.variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "identity_lang.variety_non-st",
    TRUE ~ NA_character_))%>%
  filter(Response != "continue")%>%
  select(-`Response Type`, -Target)%>%
  select(`Participant Public ID`, Response, Target_Concept, Audio, Variety, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)-> origin_authen_female
```
### clean open text "Paradigm Check"
```{r female orin_authen_para}
## separate Paradigm Check Level
origin_authen_female %>%
  mutate(
    Target_Concept = case_when(
      `Object ID` == "object-1145" ~ "Paradigm check 1",
      `Object ID` == "object-1146" ~ "Paradigm check 2",
      TRUE ~ Target_Concept)) -> origin_authen_female

# Identify  participants not deceived by the speaker illusion
## Preprocess answers to open text fields
origin_authen_female %>%
  mutate(Response_tidy = str_to_lower(Response)) -> origin_authen_female

## Create new variable (1 = deceived, 0 = not deceived)
origin_authen_female %>%
  mutate(deceived = ifelse(str_detect(Response_tidy, "(gleich|selb).{0,2} (person|sprecher|sprechende|stimme).*") |
           str_detect(Response_tidy, "(stimm).{0,2} (verstell).*"), 0, 1))%>%
  group_by(`Participant Public ID`) %>%
  mutate(deceived = case_when(
    any(deceived == 0) ~ 0,
    TRUE ~ deceived)) %>%
  ungroup() %>% 
  select(-Response_tidy) -> origin_authen_female
```
### origin & authenticity duplicates
```{r female origin authenticity_dupl}
## Check duplicates
origin_authen_female%>%
  group_by(`Participant Public ID`, Audio) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

origin_authen_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> pp_bckgr_rows # normal 168 but 4 pp above & below

origin_authen_female%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))#418


origin_authen_female%>%
  filter (`Participant Public ID` == "281162358978623" | `Participant Public ID` == "281162358538243" | `Participant Public ID` == "280560572404941" | `Participant Public ID` == "281348585302158" )-> check_pp

## => double ratings/ duplicated coz pp changed their rating at a later time OR pp selected "__other" and added answer to open Q field


## Solution: create 2 new columns
### 1) select later response of pp depending on Time Stamp

origin_authen_female %>%
  group_by(`Participant Public ID`, Audio, Target_Concept) %>%
  mutate(Response_corrected = Response[which.max(`UTC Timestamp`)])->origin_authen_female

## 2) if "_other" selected, next line text box entry into new column, then drop duplicated "_other"

origin_authen_female%>%
  mutate(Response_Text_identity_lang.var = ifelse(Response == "__other", lead(Response), NA))%>%
  ungroup()%>%
  filter(!(Response_corrected == "__other" & is.na(Response_Text_identity_lang.var)))%>%
  distinct(`Participant Public ID`, Audio, Target_Concept, Variety, .keep_all = TRUE)%>%
  select(-Response, -`Object ID`,-`UTC Date and Time`)->origin_authen_female
```
### Prep origin & authenticity join

```{r female origin authenticity_wide}

## turn long into wide format to match different data sets
origin_authen_female%>%
  pivot_wider(names_from = "Target_Concept",
              values_from = "Response_corrected")->origin_authen_female

## fill NAs with repeated values in new columns from origin_authen

# Explicitly define the new columns to be filled
new_columns_to_fill <- c("Response_Text_identity_lang.var", "Political level",
                         "identity_lang.variety_non-st", "identity_lang.variety_st",
                         "Paradigm check 1", "Paradigm check 2", "deceived")

# Fill missing values in the specified columns within each participant
 origin_authen_female %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill), .direction = "downup") %>%
  ungroup()-> origin_authen_female
```
## Combine 2 data sets: audio eval, origin & authenticity
```{r female combine tasks}

audio_eval_female %>%
   left_join(origin_authen_female, 
             by = c("Participant Public ID" = "Participant Public ID", 
                    "Audio_Track" = "Audio"))%>%
  select(-Variety)-> combined_tasks_female

## fill NAs with repeated values from origin_authen

### define the new columns to be filled: 1 x answer each participant
new_columns_to_fill_1 <- c("Political level", "Paradigm check 1", "Paradigm check 2", "deceived")

### define the new columns to be filled: 2 x answer each participant depending audio

new_columns_to_fill_2 <- c("Response_Text_identity_lang.var",                          "identity_lang.variety_non-st", "identity_lang.variety_st", "proximity_variety_non-st", "identity_lang.variety_non-st", "proximity_variety_st")

# Fill missing values in the specified columns within each participant
 combined_tasks_female %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill_1), .direction = "downup") %>%
  ungroup()-> combined_tasks_female
 
 # Fill missing values in the specified columns within each participant and audio
 combined_tasks_female %>%
   ungroup()%>%
  group_by(`Participant Public ID`, Audio_Track) %>%
  fill(all_of(new_columns_to_fill_2), .direction = "downup") %>%
  ungroup()-> combined_tasks_female
```
# Check duplicates combined data
```{r female combine data dupl}

## Check duplicates
combined_tasks_female%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

combined_tasks_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_female_rows # normal 168 but 4 pp above & below

combined_tasks_female %>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  mutate(Response = Response[which.max(`UTC Timestamp`)])%>%
  select( -`UTC Date and Time`, -`Object Name`)%>%
  distinct()->combined_tasks_female

## Check duplicates
combined_tasks_female%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates # 1pp

combined_tasks_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_female_rows # normal 168 but 1 pp below
```
# *Tasks Male vs. Female tasks*
## Audio evaluation
```{r male_vs_female audio eval}
## read data
audio_eval_male_vs_female <-read_delim(here("raw_data", "data_exp_86579-v59_task-mdix.csv"), col_names = TRUE, delim = ",")

### relevant columns for audio evaluations & rename

audio_eval_male_vs_female%>%
  select(`Participant Public ID`, `UTC Date and Time`, `UTC Timestamp`, `Response Type`, `Response`, `Object Name`, `Task Name`, `Spreadsheet: Audio`, `Spreadsheet: Speaker`, `Spreadsheet: Speaker gender`, `Spreadsheet: Variety`,
         `Spreadsheet: Political orientation`, `Spreadsheet: Stimulus number`, `Spreadsheet: Stimulus1`, `Spreadsheet: Stimulus2`, `Spreadsheet: Stimulus3`, `Spreadsheet: Stimulus4`, `Spreadsheet: Stimulus5`, 
         `Spreadsheet: Stimulus6`, `Spreadsheet: Attention Check`, `Store: Attention Check`)%>%
  rename(Audio_Track = `Spreadsheet: Audio`, Speaker = `Spreadsheet: Speaker`, Speaker_Gender = `Spreadsheet: Speaker gender`, Lang.Variety_Audio = `Spreadsheet: Variety`,
         Polit_ori = `Spreadsheet: Political orientation`, Statement_no = `Spreadsheet: Stimulus number`, Att.check_acc = `Store: Attention Check`)%>%
  filter(`Response Type` == "response")%>%
  filter (str_starts(Speaker, "Exp"))->audio_eval_male_vs_female

## remove markdown from values
audio_eval_male_vs_female%>%
mutate(across(starts_with("Spreadsheet:"), ~ str_remove_all(., "\\*\\*")))-> audio_eval_male_vs_female

## create one column with attribute related to rating
audio_eval_male_vs_female%>%
mutate(Attribute = case_when(
  `Object Name` == "RatingScale_Stimulus1" ~ `Spreadsheet: Stimulus1`,
  `Object Name` == "RatingScale_Stimulus2" ~ `Spreadsheet: Stimulus2`,
  `Object Name` == "RatingScale_Stimulus3" ~ `Spreadsheet: Stimulus3`,
  `Object Name` == "RatingScale_Stimulus4" ~ `Spreadsheet: Stimulus4`,
  `Object Name` == "RatingScale_Stimulus5" ~ `Spreadsheet: Stimulus5`,
  `Object Name` == "RatingScale_Stimulus6" ~ `Spreadsheet: Stimulus6`,
  `Object Name` == "RatingScale_AttentionCheck" ~ `Spreadsheet: Attention Check`))->audio_eval_male_vs_female

## delete unnecessary columns & elaborate levels of categorical variables
audio_eval_male_vs_female%>%
  select(-starts_with("Spreadsheet:"), -`Response Type`)%>%
  mutate(Speaker_Gender = ifelse(Speaker_Gender=="FALSE", "female", "male"))%>%
  mutate (Polit_ori = ifelse(Polit_ori == "l", "left", "right"))%>%
  mutate (Lang.Variety_Audio = ifelse(Lang.Variety_Audio == "st", "Standard German", "Regional Variety"))-> audio_eval_male_vs_female

## Identify-final-accuracy
## select final response attention check accuracy
audio_eval_male_vs_female %>%
  ungroup()%>%
  group_by(`Participant Public ID`) %>%
  mutate(Att.check_acc_last = last(Att.check_acc))%>%
  select(-Att.check_acc) %>%
  rename(Att.check_acc = Att.check_acc_last) -> audio_eval_male_vs_female

audio_eval_male_vs_female%>%
  distinct()->audio_eval_male_vs_female

## duplicates & data loss in audio_eval_male?
audio_eval_male_vs_female%>%
  group_by(`Participant Public ID`)%>%
  count()-> pp_rows # 3 pp not normal row no of 112 but above (224, 119)

```
## Origin & authenticity
```{r male_vs_female origin & authenticity}
# read data
origin_authen_male_vs_female <-read_delim(here("raw_data", "data_exp_86579-v59_task-r61o.csv"), col_names = TRUE, delim = ",")

#elaborate columns

origin_authen_male_vs_female%>%
  select(`Participant Public ID`, `Response Type`, Response, `Spreadsheet: Display`, `Spreadsheet: Audio`, `Spreadsheet: Variety`, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)%>%
  rename(Target = `Spreadsheet: Display`, Audio = `Spreadsheet: Audio`, Variety = `Spreadsheet: Variety`)%>%
  filter (`Response Type` == "response")%>%
  mutate(Target_Concept = case_when(
    Target == "Political level" ~ "Political level",
    Target == "Paradigm check" ~ "Paradigm check",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "proximity_variety_non-st",
    Target == "Origin & authenticity" & grepl("^[0-9]+$", Response) & Variety == "st" ~ "proximity_variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "st" ~ "identity_lang.variety_st",
    Target == "Origin & authenticity" & !grepl("^[0-9]+$", Response) & Variety == "non-st" ~ "identity_lang.variety_non-st",
    TRUE ~ NA_character_))%>%
  filter(Response != "continue")%>%
  select(-`Response Type`, -Target)%>%
  select(`Participant Public ID`, Response, Target_Concept, Audio, Variety, `Object ID`, `UTC Date and Time`, `UTC Timestamp`)-> origin_authen_male_vs_female
```
### clean open text "Paradigm Check"
```{r male_vs_female orin_authen_para}
## separate Paradigm Check Level
origin_authen_male_vs_female %>%
  mutate(
    Target_Concept = case_when(
      `Object ID` == "object-1145" ~ "Paradigm check 1",
      `Object ID` == "object-1146" ~ "Paradigm check 2",
      TRUE ~ Target_Concept)) -> origin_authen_male_vs_female

# Identify  participants not deceived by the speaker illusion
## Preprocess answers to open text fields
origin_authen_male_vs_female %>%
  mutate(Response_tidy = str_to_lower(Response)) -> origin_authen_male_vs_female

## Create new variable (1 = deceived, 0 = not deceived)
origin_authen_male_vs_female %>%
  mutate(deceived = ifelse(str_detect(Response_tidy, "(gleich|selb).{0,2} (person|sprecher|sprechende|stimme).*") |
           str_detect(Response_tidy, "(stimm).{0,2} (verstell).*"), 0, 1))%>%
  group_by(`Participant Public ID`) %>%
  mutate(deceived = case_when(
    any(deceived == 0) ~ 0,
    TRUE ~ deceived)) %>%
  ungroup() %>% 
  select(-Response_tidy) -> origin_authen_male_vs_female
```
### origin & authenticity duplicates
```{r male_vs_female origin authenticity_dupl}

## Check duplicates
origin_authen_male_vs_female%>%
  group_by(`Participant Public ID`, Audio) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

origin_authen_male_vs_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> pp_bckgr_rows

origin_authen_male_vs_female%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))#451


## => double ratings/ duplicated coz pp changed their rating at a later time OR pp selected "__other" and added answer to open Q field


## create 2 new columns
### 1) select later response of pp depending on Time Stamp

origin_authen_male_vs_female %>%
  group_by(`Participant Public ID`, Audio, Target_Concept) %>%
  mutate(Response_corrected = Response[which.max(`UTC Timestamp`)])->origin_authen_male_vs_female

## 2) if "_other" selected, next line text box entry into new column, then drop duplicated "_other"

origin_authen_male_vs_female%>%
  mutate(Response_Text_identity_lang.var = ifelse(Response == "__other", lead(Response), NA))%>%
  ungroup()%>%
  filter(!(Response_corrected == "__other" & is.na(Response_Text_identity_lang.var)))%>%
  distinct(`Participant Public ID`, Audio, Target_Concept, Variety, .keep_all = TRUE)%>%
  select(-Response, -`Object ID`,-`UTC Date and Time`)->origin_authen_male_vs_female
```
# Prep origin & authenticity join

```{r male_vs_female origin authenticity_wide}

## turn long into wide format to match different data sets
origin_authen_male_vs_female%>%
  pivot_wider(names_from = "Target_Concept",
              values_from = "Response_corrected")->origin_authen_male_vs_female

## fill NAs with repeated values in new columns from origin_authen

# Explicitly define the new columns to be filled
new_columns_to_fill <- c("Response_Text_identity_lang.var", "Political level",
                         "identity_lang.variety_non-st", "identity_lang.variety_st",
                         "Paradigm check 1", "Paradigm check 2", "deceived")

# Fill missing values in the specified columns within each participant
 origin_authen_male_vs_female %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill), .direction = "downup") %>%
  ungroup()-> origin_authen_male_vs_female
```
## Combine 2 data sets: audio eval, origin & authenticity
```{r male_vs_female combine tasks}

audio_eval_male_vs_female %>%
   left_join(origin_authen_male_vs_female, 
             by = c("Participant Public ID" = "Participant Public ID", 
                    "Audio_Track" = "Audio"))%>%
  select(-Variety)-> combined_tasks_male_vs_female

## fill NAs with repeated values from origin_authen

### define the new columns to be filled: 1 x answer each participant
new_columns_to_fill_1 <- c("Political level", "Paradigm check 1", "Paradigm check 2", "deceived")

### define the new columns to be filled: 2 x answer each participant depending audio

new_columns_to_fill_2 <- c("Response_Text_identity_lang.var",                          "identity_lang.variety_non-st", "identity_lang.variety_st", "proximity_variety_non-st", "identity_lang.variety_non-st", "proximity_variety_st")

# Fill missing values in the specified columns within each participant
 combined_tasks_male_vs_female %>%
  group_by(`Participant Public ID`) %>%
  fill(all_of(new_columns_to_fill_1), .direction = "downup") %>%
  ungroup()-> combined_tasks_male_vs_female
 
 # Fill missing values in the specified columns within each participant and audio
 combined_tasks_male_vs_female %>%
   ungroup()%>%
  group_by(`Participant Public ID`, Audio_Track) %>%
  fill(all_of(new_columns_to_fill_2), .direction = "downup") %>%
  ungroup()-> combined_tasks_male_vs_female
 
 ## improve measurement? Only fill new_columns_to_fill_2 where Audio_Track is not NA
```
# Check duplicates combined data
```{r male_vs_female combine data dupl}
## Check duplicates
combined_tasks_male_vs_female%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates

combined_tasks_male_vs_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_male_vs_female_rows # normal 112 but 3 pp above 

combined_tasks_male_vs_female %>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  mutate(Response = Response[which.max(`UTC Timestamp`)])%>%
  select(-`UTC Date and Time`, -`Object Name`)%>%
  distinct()->combined_tasks_male_vs_female

## Check duplicates
combined_tasks_male_vs_female%>%
  group_by(`Participant Public ID`, Audio_Track, Attribute) %>%
  summarise(n = n(), .groups = "drop") %>%
  filter(n > 1L)-> duplicates #

combined_tasks_male_vs_female%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_tasks_male_vs_female_rows # all normal 112
```
# combine all task data

```{r combine data all}

bind_rows(combined_tasks_female, combined_tasks_male, combined_tasks_male_vs_female)->data_tasks

data_tasks%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))

as.factor(data_tasks$`Task Name`)->data_tasks$`Task Name`


data_tasks%>%
  ungroup()%>%
 count(`Task Name`,`Speaker_Gender`,`Participant Public ID`)-> rows_per_condition

```
# *Background Questionnaire*
## Prep
```{r questionnaire1-Prep}

## read data
questionnaire <- read_delim(here("raw_data", "data_exp_86579-v59_questionnaire-ry6q.csv"), col_names = TRUE, delim = ",")
as_tibble(questionnaire)

# get relevant columns'

questionnaire%>%
  filter(`Event Index` != "END OF FILE")%>%
  select ("Participant Public ID", "Participant Status", "UTC Timestamp", "Participant OS", "Participant Browser", "Task Name", "counterbalance-nimi", "counterbalance-x3xi", "counterbalance-xq3l", "randomiser-rtb5", "age", "gender", "state_of_residence", "education_school", "education_profession1", "education_profession2", "income", "profession", "profession-text", starts_with("languages_caregiver1"), starts_with("languages_caregiver2"), starts_with("political_"), "other_languages", "own_dialect", "own_dialect-quantised", "party", "party-text", "party-quantised", matches("^social_desirability_[A-I]-quantised$"), matches("^populism_[A-D]$"))-> questionnaire

# prep: assign classes
as.factor(questionnaire$`Participant Public ID`)->questionnaire$`Participant Public ID`
as.numeric(questionnaire$age)->questionnaire$age
as.factor(questionnaire$gender)->questionnaire$gender
as.factor(questionnaire$state_of_residence)->questionnaire$state_of_residence
as.factor(questionnaire$education_school)->questionnaire$education_school
as.factor(questionnaire$education_profession1)->questionnaire$education_profession1
as.factor(questionnaire$education_profession2)->questionnaire$education_profession2
as.factor(questionnaire$income)->questionnaire$income
as.factor(questionnaire$profession)->questionnaire$profession
as.numeric(questionnaire$political_spectrum)->questionnaire$political_spectrum
as.numeric(questionnaire$own_dialect)->questionnaire$own_dialect
as.factor(questionnaire$party)->questionnaire$party

```
## identify multiple participation

```{r questionnaire2-Multi}
questionnaire %>%
  group_by (`Participant Public ID`)%>%
  summarise (n_distinct (`UTC Timestamp`))-> multi_part 

```
## questionnaire into 2 data sets
### data set 1: participant background: technical stuff & demographics

```{r questionnaire2-pp_bckgr}
questionnaire%>%
  select("Participant Public ID", "Participant Status", "Participant OS", "Participant Browser", "Task Name", "counterbalance-nimi", "counterbalance-x3xi", "counterbalance-xq3l", "randomiser-rtb5", "age", "gender", "state_of_residence", "education_school", "education_profession1", "education_profession2", "income", "profession", "profession-text")->pp_bckgr

## create new dummy variables education

pp_bckgr%>%
  mutate (education_profession1_sum = case_when
          (education_profession1 == "Berufsfachschulabschluss" ~ "low",
            education_profession1 == "Fachhochschulabschluss" ~ "high",
            education_profession1 == "Fachschulabschluss" ~ "middle",
            education_profession1 == "Hochschulabschluss (Bachelor)" ~ "high",
            education_profession1 == "Hochschulabschluss (Master)" ~ "high",
            education_profession1 == "Hochschulabschluss (Promotion)" ~ "high",
            education_profession1 == "Keinen" ~ "low",
            education_profession1 == "Meister/in, Technikerabschluss" ~ "middle",
            education_profession1 == "Teilfacharbeiterabschluss" ~ "low",
            education_profession1 == "Abgeschlossene gewerbliche oder landwirtschaftliche Lehre" ~ "middle",
            education_profession1 == "Abgeschlossene kaufmännische Lehre" ~ "middle",
            education_profession1 == "beruflich-betriebliche Anlernzeit mit Abschlusszeugnis, aber keine Lehre" ~ "low", TRUE ~ NA))-> pp_bckgr


pp_bckgr%>%
  mutate (education_school_sum = case_when
          (education_school == "Schule beendet ohne Abschluss"  ~ "low",
            education_school == "Hauptschulabschluss/ Volksschulabschluss/ Abschluss der polytechnischen Oberschule 8. oder 9. Klasse" ~ "low",
            education_school == "Realschulabschluss/ Mittlere Reife/ Fachschulreife oder Abschluss der polytechnischen Oberschule 10. Klasse" ~ "middle",
            education_school == "Fachhochschulreife (Abschluss einer Fachoberschule etc.)" ~ "high",
            education_school == "Abitur bzw. erweiterte Oberschule mit Abschluss 12. Klasse (Hochschulreife)" ~ "high",
            education_school == "bin noch Schüler/in" ~ "still at school",
            education_school == "andere" ~ "other",
            education_school == "NA" ~ "NA", TRUE ~ NA))-> pp_bckgr

pp_bckgr%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> pp_bckgr_rows # 1 per pp

pp_bckgr%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))#1315
```
## data set 2: language & poplitical background
```{r questionnaire2-lang_pop}
questionnaire%>%
  select("Participant Public ID", starts_with("languages_caregiver1"), starts_with("languages_caregiver2"), "other_languages", "own_dialect", "party", "party-text", matches("^social_desirability_[A-I]-quantised$"), matches("^populism_[A-D]$"), starts_with("political_"), `UTC Timestamp`)-> pp_lang_pop_wide



pp_lang_pop_wide%>%
  select( -`political_orientation_A-quantised`, -`political_orientation_B-quantised`, -`political_orientation_C-quantised`, -`political_orientation_D-quantised`, -`political_spectrum_other-quantised`)%>%
  pivot_longer(cols = 2:45, names_to = "variety_numeric", values_to = "lang.variety")%>%
  drop_na(lang.variety)-> pp_lang_pop

# pp_lang_pop%>%
  #mutate(ingroup= case_when (variety_numeric == "languages_caregiver1-15" | variety_numeric == "languages_caregiver2-15" ~ "Swabian", variety_numeric == "languages_caregiver1-1" | variety_numeric == "languages_caregiver2-1"  "other"))-> pp_lang_pop # achieves same as below new ingroup variable no?


pp_lang_pop%>%
  mutate(caregiver= ifelse (str_detect(variety_numeric, "^languages_caregiver1"), "caregiver1", "caregiver2"))->pp_lang_pop

## new column for text box "anderer Dialekt"

as.factor(pp_lang_pop$variety_numeric)-> pp_lang_pop$variety_numeric

levels(pp_lang_pop$variety_numeric)
pp_lang_pop%>%
  mutate(Response_Text_Other_Dialect = ifelse(lang.variety == "Anderer Dialekt", lag(lang.variety), NA))%>%
  filter(`variety_numeric` != "languages_caregiver2-text" &`variety_numeric`!= "languages_caregiver1-text" )%>%
select(-`variety_numeric`)%>%
  ungroup()-> pp_lang_pop

### duplicates for caregiver?
pp_lang_pop %>%
  count(`Participant Public ID`, caregiver) %>%
  filter(n > 1)->duplicates # 4 pp

pp_lang_pop%>%
  filter (`Participant Public ID`== "281162358882340" | `Participant Public ID`== "281093395266704" | `Participant Public ID`== "281348585319612"| `Participant Public ID`== "280560572371198")-> check_dup # multiple answers for lang variety care giver same time stamp
```
# New variable in-/ outgroup lang. variety
```{r questionnaire2-lang_pop}
as.factor(pp_lang_pop$lang.variety)->pp_lang_pop$lang.variety
levels(pp_lang_pop$lang.variety)

pp_lang_pop%>%
  group_by(`Participant Public ID`, caregiver)%>%
  mutate (lang.exposure = case_when(lang.variety == "Schwäbisch" ~ "in-group",
                                    lang.variety == "Alemannisch" | lang.variety == "Anderer Dialekt"| lang.variety == "Badisch"  |  lang.variety == "Bairisch" |lang.variety ==  "Fränkisch" | lang.variety == "Hessisch" |                          lang.variety == "Moselfränkisch" | lang.variety ==  "Norddeutsch" | lang.variety == "Ostdeutsch"  |  lang.variety == "Österreichisch" | lang.variety == "Pfälzisch" |  lang.variety ==  "Plattdeutsch" | lang.variety ==  "Rheinisch" | lang.variety == "Saarländisch" |  lang.variety ==  "Sächsisch" |lang.variety == "Schweizerdeutsch" | lang.variety == "Thüringisch" ~ "out-group_dialect", 
  lang.variety == "Dialekt/Sprache aus dem nicht-deutschsprachigen Ausland" ~ "multilingual", lang.variety == "Hochdeutsch"  ~ "Hochdeutsch", lang.variety == "Ich weiß nicht" ~ "Ich weiß nicht", 
      FALSE ~ NA))->  pp_lang_pop   

as.factor(pp_lang_pop$lang.exposure)->pp_lang_pop$lang.exposure
pp_lang_pop%>%
  ungroup()%>%
  group_by(lang.exposure, caregiver)%>%
  summarise (n_distinct(`Participant Public ID`))-> Sum_lang.expos_pp_lang_pop

```
# Standardise open text answer caregiver language
```{r questionnaire3-lang_pop_standardise, eval=FALSE, include=FALSE}

pp_lang_pop %>%
  mutate(Response_Text_Other_Dialect_check = ifelse(!is.na(Response_Text_Other_Dialect), str_to_lower(Response_Text_Other_Dialect), NA))-> pp_lang_pop
  

pp_lang_pop_test %>%
  mutate(lang.caregivers_sub = case_when(
    Response_Text_Other_Dialect %in% c("Berlin", "Berliner", "Berliner Deutsch", "Berliner Dialekt", "Berlinerisch") ~ "Berlinerisch",
   Response_Text_Other_Dialect %in% c("Ruhrgebiet", "Ruhrpott", "Ruhrpottslang", "Ruhrdeutsch") ~ "Ruhrdeutsch",
    Response_Text_Other_Dialect %in% c("Brandenburg", "Brandenburgisch") ~ "Brandenburgisch",
    Response_Text_Other_Dialect %in% c("Fränkisch", "Plattdeutsch", "Bayrisch") ~ NA_character_,
    TRUE ~ Response_Text_Other_Dialect
  )) -> pp_lang_pop_test

#### sort answers into existing categories
pp_lang_pop_special %>%
  mutate(lang.caregivers_hom = case_when(
    `languages_caregivers-text` %in% c("Bayrisch", "Münchnerisch") ~ "Bairisch",
    lang.caregivers_sub == "Berlinerisch" ~ "Ostdeutsch",
    `languages_caregivers-text` %in% c("Russisch", "Ungarisch", "Venezianisch", "Polnisch") ~ "Dialekt/Sprache aus dem nicht-deutschsprachigen Ausland",
    `languages_caregivers-text` %in% c("Ruhrgebiet", "Ruhrpott", "Ruhrpottslang", "Ruhrdeutsch") ~ "Ruhrdeutsch",
    `languages_caregivers-text` %in% c("Mannheimerisch", "Oberpfälzerisch", "Kurpfälzisch") ~ "Pfälzisch",
    `languages_caregivers-text` == "Rheinhessisch" ~ "Hessisch",
    `languages_caregivers-text` %in% c("Niederösterreichisch", "Wienerisch") ~ "Österreichisch",
    `languages_caregivers-text` %in% c("Schlesisch", "Oberlausitzer Dialekt", "Vogtlandisch (Fränkisch)", "Niederlausitzer Mundart", "Brandenburg", "Brandenburgisch", "Erzgebirgisch") ~ "Ostdeutsch",
    `languages_caregivers-text` %in% c("Siegerländer Plattdeutsch", "Eifeler Deutsch") ~ "Moselfränkisch",
    `languages_caregivers-text` == "Kölsch" ~ "Rheinisch",
    `languages_caregivers-text` == "Fränkisch" ~ "Fränkisch",
    `languages_caregivers-text` == "Plattdeutsch" ~ "Plattdeutsch"
    )) -> pp_lang_pop_special
```
# join questionnaire data sets: 
```{r join questionnaire data}
pp_lang_pop%>%
left_join (pp_bckgr, by= c("Participant Public ID" = "Participant Public ID"))-> combined_questionnaire

combined_questionnaire%>%
filter (`Participant Public ID` != "280475315358931")%>%
  select(-`Task Name`)->combined_questionnaire


```
## Summary tables for questionnaire
```{r summary tables}
## check randomization:

combined_questionnaire%>%
  group_by(`randomiser-rtb5`,`counterbalance-nimi`, `counterbalance-x3xi`, `counterbalance-xq3l`)%>%
  summarise(n_distinct(`Participant Public ID`))->random


## check: participant background

### federal state

combined_questionnaire%>%
  group_by(state_of_residence)%>%
  summarise(n_distinct(`Participant Public ID`))->pp_state

### participant age

combined_questionnaire%>%
  ungroup()%>%
  drop_na(age)%>%
  summarise(mean(age), sd(age), min (age), max (age))->pp_age

### participant gender

combined_questionnaire%>%
  group_by(gender)%>%
  summarise(n_distinct(`Participant Public ID`))->pp_gender

### sum_education_school
combined_questionnaire%>%
  ungroup()%>%
  group_by(education_school_sum)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_education

### education
combined_questionnaire%>%
  group_by(education_school)%>%
  summarise(n_distinct(`Participant Public ID`))->education

### sum_profession
combined_questionnaire%>%
  group_by(education_profession1_sum)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_profession1


### income

combined_questionnaire%>%
  group_by(income)%>%
  summarise(n_distinct(`Participant Public ID`))->income

### profession

combined_questionnaire%>%
  group_by(profession)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_profession


combined_questionnaire%>%
  group_by (`Participant Public ID`)%>%
  count(`Participant Public ID`)-> combined_q_rows # 1-14 rows per pp
# 281162358882340


combined_questionnaire%>%
  distinct_all()->combined_questionnaire2# same

combined_questionnaire%>%
  ungroup()%>%
  summarise(n_distinct(`Participant Public ID`))#1313

combined_questionnaire%>%
  group_by(party)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_party

combined_questionnaire%>%
  group_by(lang.variety)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_lang.variety_caregiver

combined_questionnaire%>%
  group_by(caregiver, lang.variety)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_caregiver_lang

combined_questionnaire%>%
  summarise(mean(own_dialect), sd (own_dialect), min (own_dialect), max(own_dialect))->own_lang.variety
```
# combine questionaire with task data

```{r question_task_combine}

# Ensure matching data types and trim whitespace
data_tasks <- data_tasks %>%
  mutate(`Participant Public ID` = as.character(trimws(`Participant Public ID`)))

combined_questionnaire <- combined_questionnaire %>%
  mutate(`Participant Public ID` = as.character(trimws(`Participant Public ID`)))

# Check for common Participant Public ID values
common_ids <- intersect(data_tasks$`Participant Public ID`, combined_questionnaire$`Participant Public ID`)

# Display the number of common IDs
length(common_ids)


# find unique compound keys

data_tasks %>%
  count(`Participant Public ID`, Audio_Track, Attribute) %>%
  filter(n > 1) # yes, unique key

combined_questionnaire %>%
  count(`Participant Public ID`, caregiver, lang.variety) %>%
  filter(n > 1) # yes unique key

# create unique keys

data_tasks <- data_tasks %>%
  mutate(unique_key = paste(`Participant Public ID`, Audio_Track, Attribute, sep = "_"))

combined_questionnaire <- combined_questionnaire %>%
  mutate(unique_key = paste(`Participant Public ID`, caregiver, lang.variety, sep = "_"))


data_tasks %>%
  ungroup()%>%
  summarise(
    na_Participant_Public_ID = sum(is.na(`Participant Public ID`)),
    na_Audio_Track = sum(is.na(Audio_Track)),
    na_Attribute = sum(is.na(Attribute)))->na_data_task


combined_questionnaire %>%
  ungroup()%>%
  summarise(
    na_Participant_Public_ID = sum(is.na(`Participant Public ID`)),
    na_caregiver = sum(is.na(caregiver)),
    na_lang.variety = sum(is.na(lang.variety)))->na_compl_questionnaire

colnames(data_tasks)
colnames(combined_questionnaire)

data_tasks %>%
  left_join(combined_questionnaire)->data_all

# Joining with `by = join_by(`Participant Public ID`, unique_key)`


# data_all %>%
  #distinct(`Participant Public ID`, `Audio_Track`, `Attribute`, .keep_all = TRUE)-> data_all
```
# Final data set
```{r check_final_data}

colnames(data_all)

# NAs

data_all%>%
  group_by(`Participant Public ID`) %>%
  summarise(na_count_pop_A = sum(is.na(populism_A)), na_count_pop_B = sum(is.na(populism_B)), na_count_pop_C = sum(is.na(populism_C)), na_count_pop_D = sum(is.na(populism_D)))->NA_pop

data_all%>%
  group_by(`Participant Public ID`) %>%
  summarise(na_count_caregiver = sum(is.na(caregiver)), na_count_lang.var = sum(is.na(lang.variety)), na_count_own_dialect = sum(is.na(own_dialect)), na_count_party= sum(is.na(party)))->NA_quest

# incomplete data

# levels complete of questionnaire

as.factor(data_all$caregiver)-> data_all$caregiver
data_all%>%
  group_by(`Participant Public ID`) %>%
  summarise(caretaker_levels = unique(data_all$caregiver))-> caretaker_levels 

data_all%>%
  group_by(caregiver, lang.variety)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_caregiver_lang

# caregiver data missing -> NAs

data_all%>%
  group_by(`Task Name`, `Participant Public ID`)%>%
  count()-> pp_rows # works 112 for male vs female 168 for only condition


data_all%>%
  group_by(gender)%>%
  summarise(n_distinct(`Participant Public ID`))->pp_gender

data_all%>%
  ungroup()%>%
    drop_na(own_dialect)%>%
  summarise(mean(own_dialect), sd (own_dialect), min (own_dialect), max(own_dialect))->own_lang.variety 

data_all%>%
  group_by(party)%>%
  summarise(n_distinct(`Participant Public ID`))->sum_party

```
# Final data set

```{r write csv final data}

write_delim(data_all, here("data_processed", "data_clean.csv"), col_names = TRUE, delim = ",")
```

